{"version":3,"sources":["../../projects/ngx-golden-layout/src/lib/config.ts","../../../node_modules/tslib/tslib.es6.js","../../projects/ngx-golden-layout/src/lib/deferred.ts","../../projects/ngx-golden-layout/src/lib/multiwindow-service.ts","../../projects/ngx-golden-layout/src/lib/plugin-url.service.ts","../../projects/ngx-golden-layout/src/lib/plugin-registry.service.ts","../../projects/ngx-golden-layout/src/lib/tokens.ts","../../projects/ngx-golden-layout/src/lib/type-guards.ts","../../projects/ngx-golden-layout/src/lib/wrapper.component.ts","../../projects/ngx-golden-layout/src/lib/component-registry.service.ts","../../projects/ngx-golden-layout/src/lib/fallback.ts","../../projects/ngx-golden-layout/src/lib/root-window.service.ts","../../projects/ngx-golden-layout/src/lib/window-sync.service.ts","../../projects/ngx-golden-layout/src/lib/golden-layout.component.ts","../../projects/ngx-golden-layout/src/lib/module.ts"],"names":["GoldenLayoutComponents","InjectionToken","GoldenLayoutPluginDependency","Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","Deferred","_this","this","promise","Promise","resolve","reject","MultiWindowInit","isChildWindow","window","__services","__serviceConstructors","Map","require","originalWindowOpen_1","open","bind","url","target","features","replace","newWindow","opener","location","href","MultiWindowService","uniqueName","constructor","constr","rootWindow","rootWindowIsMyWindow","constrGot","get","Error","set","newConstructor","args","_i","hasInstance","has","storedConstr","apply","prop","hasOwnProperty","metadata","Reflect","getMetadata","_a","PluginURLProvider","loadedURLs","loads","Subject","unloads","prototype","loadRequests$","unloadRequests$","allPlugins","entries","map","p","id","requestLoad","requestUnload","delete","Injectable","decorators","key","desc","d","c","getOwnPropertyDescriptor","decorate","defineProperty","__decorate","MockPluginRegistryService","pluginLoaded$","pluginUnloaded$","startLoadPlugin","startUnloadPlugin","PluginRegistryService","deps","urlProvider","injector","availableDependencies","loadedPlugins","console","log","forEach","x","name","loader","patchWindow","subscribe","load","waitForPlugin","module","newPlugin","script","moduleRef","define","moduleId","factory","depsExports","slice","catch","err","warn","undefined","all","then","exports","moduleKlass","MODULE","moduleFactory","ÉµNgModuleFactory","amd","document","createElement","onerror","type","src","body","appendChild","unload","Inject","Optional","Injector","GoldenLayoutContainer","GoldenLayoutComponentState","GoldenLayoutEventHub","GoldenLayoutComponentHost","implementsGlOnResize","obj","glOnResize","implementsGlOnShow","glOnShow","implementsGlOnHide","glOnHide","implementsGlOnTab","glOnTab","WrapperComponent","host","container","state","destroyed","initialized","originalComponent","getGoldenLayoutInstance","_getAllComponents","originalId","instance","headerComponent","additionalTokens","ngOnInit","componentRef","redock","getElement","ngOnDestroy","cr","to","el","$","nativeElement","remove","append","tab","Component","selector","encapsulation","ViewEncapsulation","None","template","ComponentRegistryService","initialComponents","pluginRegistry","components","awaitedComponents","registerComponent","_b","registeredTokens","assign","plugin","registeredComponents","componentMap","component","otherComponent","waitForComponent","FallbackComponent","FailedComponent","RootWindowService","getRootWindow","MockWindowSynchronizerService","restoreAppRefTick","onUnload","WindowSynchronizerService","appref","rootService","unloaded","topWindow","title","URL","__log","anyWin","__apprefs","__injector","__tick","tick","_zone","run","_c","index","indexOf","splice","ApplicationRef","lm","GoldenLayout","isCloned","contentItem","isComponent","config","componentState","GetComponentFromLayoutManager","itemList","root","getItemsById","comp","layoutManager","tabFromId","ci","originalTab","__lm","controls","Tab","newTab","header","tabContentItem","closeElement","off","on","ev","stopPropagation","close","element","emit","_layoutManager","settings","reorderEnabled","_dragListener","dl_1","destroyDummy_1","_maximisedItem","parent","toggleMaximise","_onDragStart","_fDown","_template","originalHeader","Header","newHeader","maximise","_header","popout","maximiseAllItems","popoutButton","HeaderButton","activeContentItem","popoutWholeStack","maximiseButton","generateAndMaximiseDummyStack","closeButton","_$destroy","label","_getHeaderSetting","contentItems","join","origDragProxy","DragProxy","dragProxy","y","dragListener","originalParent","origStack","items","Stack","MyStack","activeContentItem$","BehaviorSubject","callback","origDestroy","___destroyed","complete","content","idx","addChild","setActiveContentItem","activeItemIndex","width","height","setSize","origPopout","BrowserPopout","dimensions","getQueryStringParam","utils","firstQueryString","param","GoldenLayoutComponent","componentRegistry","viewContainer","componentFactoryResolver","ngZone","windowSync","parentGoldenLayout","fallbackComponent","stateChanged","EventEmitter","tabActivated","goldenLayout","onUnloaded","stateChangePaused","stateChangeScheduled","tabsList","pushStateChange","requestAnimationFrame","resumeStateChange","pauseStateChange","pushTabActivated","fallbackType","openedComponents","poppedIn","_eventEmitter","buildConstructor","isDevMode","onResize","updateSize","layoutSubscription","layout","destroyGoldenLayout","initializeGoldenLayout","beforeUnload","pageHide","glOnUnload","unsubscribe","_mSubscriptions","ALL_EVENT","addEvent","kind","context","getSerializableState","configObj","toConfig","wrapperMax","__wrapperMaximisedItemId","maximisedItemId","filterContent_1","isDummy","filter","getComponents","closeComponent","focusComponent","createNewComponent","componentToDock","myConfig","isStack","stack","createContentItem","replaceChild","findStack","contentItems_1","contentItems_1_1","destroy","createPopout","item","dim","rec","itemToProcess","shift","__ngComponent","glOnPopout","buildComponentMap","ret","componentIdList","keys","rootContentItem","k","componentName","isClosable","findIndex","j","_activeContentItem","myStack","teardown$","pipe","takeUntil","distinctUntilChanged","a","b","keysA","keysB","Set","size","every","targetState","workingCopy","tabs","openedTabs","tabs_1","tabs_1_1","find","openedTabs_1","openedTabs_1_1","glOnPopin","getComponent","customHeaderElement","classList","add","style","display","ctr","controlsContainer","prepend","disposeControl","childNodes","removeChild","_updateTabSizes","switchMap","of","inst","tokens","ct","resolveComponentFactory","headerInjector","createComponent","bootstrapComponent","init","self","glComponent","Math","random","toString","componentType","failedComponent","_config","_createComponentInjector","_bindEventHooks","destroyFn","failed","providers","provide","useValue","eventHub","glOnClose","containerClose_1","ViewContainerRef","ComponentFactoryResolver","NgZone","SkipSelf","Input","Output","ViewChild","static","HostListener","GoldenLayoutModule","forRoot","types","fallback","pluginDeps","ngModule","config.GoldenLayoutComponents","ANALYZE_FOR_ENTRY_COMPONENTS","multi","config.GoldenLayoutPluginDependency","forChild","useClass","NgModule","declarations","imports","CommonModule"],"mappings":"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","sourcesContent":["import { InjectionToken, Type } from '@angular/core';\r\nimport * as GoldenLayout from 'golden-layout';\r\n\r\nexport interface ComponentType {\r\n  /**\r\n   * Optional string indicating that this component type is handled by the plugin\r\n   * specified in this field.\r\n   */\r\n  plugin?: string;\r\n  /**\r\n   * Name used to register compoent with GoldenLayout.\r\n   * Must be unique over all component types\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Angular component type.\r\n   * Pass the class of the component to instantiate here.\r\n   */\r\n  type: Type<any>;\r\n}\r\n\r\nexport interface PluginDependencyType {\r\n  /**\r\n   * Fully qualified module name of the dependency\r\n   */\r\n  name: string;\r\n  /**\r\n   * Function that loads the dependency\r\n   * Might return an object (direct load) OR a promise (deferred loading using import() syntax)\r\n   */\r\n  loader: any;\r\n}\r\n\r\n/**\r\n * Inject an array of ComponentType into this token to\r\n * register those by default with the ComponentRegistry\r\n */\r\nexport const GoldenLayoutComponents = new InjectionToken<ComponentType[]>('ComponentTypes');\r\n\r\n/**\r\n * Inject dependency modules to be used with the PluginRegistry\r\n * This token can use multi: true\r\n */\r\nexport const GoldenLayoutPluginDependency = new InjectionToken<PluginDependencyType[]>('Dependencies');\r\n\r\nexport interface IExtendedGoldenLayoutConfig extends GoldenLayout.Config {\r\n  settings: GoldenLayout.Config['settings'] & {\r\n    /**\r\n     * Use alternate maximise method that moves *all* tabs to the single root.\r\n     */\r\n    maximiseAllItems?: boolean;\r\n  };\r\n}\r\n\r\nexport interface IExtendedGoldenLayoutContainer extends GoldenLayout.Container {\r\n  /**\r\n   * Unique id for the container\r\n   */\r\n  id: string;\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export class Deferred<T> {\r\n  public promise: Promise<T>;\r\n  public resolve: (val: T) => void;\r\n  public reject: (reason: Error | string) => void;\r\n  constructor() {\r\n    this.promise = new Promise<T>((resolve, reject) => {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n    });\r\n  }\r\n}\r\n","export function MultiWindowInit(): void {\r\n  if (!isChildWindow()) {\r\n    if (!(window as any).__services && !(window as any).__serviceConstructors) {\r\n      (window as any).__services = new (window as any).Map();\r\n      (window as any).__serviceConstructors = new (window as any).Map();\r\n\r\n      // Electron compatibility, when we have a global 'require' in our window, we throw it into the new window context\r\n      if ((window as any).require) {\r\n        const originalWindowOpen = window.open.bind(window);\r\n        window.open = (url?: string, target?: string, features?: string, replace?: boolean): Window => {\r\n          const newWindow = originalWindowOpen(url, target, features, replace);\r\n          newWindow.require = (window as any).require;\r\n          return newWindow;\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport type Constructor<T> = {\r\n  new (...args: any[]): T;\r\n}\r\n\r\nexport function isChildWindow(): boolean {\r\n  try {\r\n    return !!window.opener && !!window.opener.location.href;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function MultiWindowService<T>(uniqueName: string) {\r\n  MultiWindowInit();\r\n  return function (constructor: Constructor<T>): Constructor<T> {\r\n    const constr = constructor as any;\r\n    const rootWindow = (isChildWindow() ? window.opener : window) as any;\r\n    const rootWindowIsMyWindow = rootWindow === window;\r\n    if (rootWindowIsMyWindow) {\r\n      const constrGot = rootWindow.__serviceConstructors.get(uniqueName);\r\n      if (constrGot && constrGot !== constr) {\r\n        throw new Error(`MultiWindowService(): uniqueName ${uniqueName} already taken by ${constrGot}, wanted by ${constr}`);\r\n      }\r\n      rootWindow.__serviceConstructors.set(uniqueName, constr);\r\n    }\r\n    const newConstructor = (function(...args: any[]): T {\r\n      const hasInstance = rootWindow.__services.has(uniqueName);\r\n      if (!hasInstance) {\r\n        const storedConstr = rootWindow.__serviceConstructors.get(uniqueName) || constr;\r\n        rootWindow.__services.set(uniqueName, new storedConstr(...args));\r\n      }\r\n      return rootWindow.__services.get(uniqueName);\r\n    }) as any;\r\n    if (rootWindowIsMyWindow) {\r\n      // https://github.com/angular/angular/issues/36120\r\n      // Éµfac is created before this decorator runs.\r\n      // so copy over the static properties.\r\n      for (const prop in constr) {\r\n        if (constr.hasOwnProperty(prop)) {\r\n          newConstructor[prop] = constr[prop];\r\n        }\r\n      }\r\n    }\r\n    try {\r\n      if (rootWindowIsMyWindow) {\r\n        const metadata = (Reflect as any).getMetadata('design:paramtypes', constr);\r\n        (Reflect as any).metadata('design:paramtypes', metadata)(newConstructor);\r\n      }\r\n    } catch {\r\n      // obviously, we're in ivy.\r\n    }\r\n    return newConstructor as Constructor<T>;\r\n  };\r\n}\r\n","import { MultiWindowService } from './multiwindow-service';\r\nimport { Injectable } from '@angular/core';\r\nimport { Subject, Observable } from 'rxjs';\r\n\r\n\r\nexport interface IPluginURL {\r\n  id: string,\r\n  url: string,\r\n};\r\n\r\n/**\r\n * This class manages plugin load and unload requests across all windows.\r\n * Because we can't have progress reporting about all windows, we also don't\r\n * return any progress/success indicator here.\r\n */\r\n@MultiWindowService<PluginURLProvider>('_gl__PluginURLProvider')\r\n@Injectable()\r\nexport class PluginURLProvider {\r\n  private loadedURLs = new Map<string, string>();\r\n  private loads = new Subject<IPluginURL>();\r\n  private unloads = new Subject<string>();\r\n\r\n  public loadRequests$(): Observable<IPluginURL> {\r\n    return this.loads;\r\n  }\r\n  public unloadRequests$(): Observable<string> {\r\n    return this.unloads;\r\n  }\r\n  public allPlugins(): IPluginURL[] {\r\n    return [...this.loadedURLs.entries()].map(p => ({ id: p[0], url: p[1] }));\r\n  }\r\n\r\n  public requestLoad(id: string, url: string) {\r\n    const p = this.loadedURLs.get(id);\r\n    if (p) {\r\n      if (p !== url) {\r\n        throw new Error(`Plugin ${id} is already loaded with another URL`);\r\n      }\r\n      return;\r\n    }\r\n    this.loadedURLs.set(id, url);\r\n    this.loads.next({ id, url });\r\n  }\r\n\r\n  public requestUnload(id: string) {\r\n    const p = this.loadedURLs.get(id);\r\n    if (!p) {\r\n      throw new Error(`Plugin ${id} is not loaded`);\r\n    }\r\n    this.loadedURLs.delete(id);\r\n    this.unloads.next(id);\r\n  }\r\n}\r\n","import { Injectable, Inject, Optional, Injector, NgModuleRef, ÉµNgModuleFactory } from '@angular/core';\r\nimport { GoldenLayoutPluginDependency, PluginDependencyType } from './config';\r\nimport { Deferred } from './deferred';\r\nimport { Subject } from 'rxjs';\r\nimport { PluginURLProvider, IPluginURL } from './plugin-url.service';\r\n\r\ninterface IPluginState {\r\n  id: string,\r\n  url: string,\r\n  module: Deferred<any>,\r\n  moduleRef: NgModuleRef<any>,\r\n  script: HTMLScriptElement,\r\n};\r\n\r\n@Injectable()\r\nexport class MockPluginRegistryService {\r\n  public pluginLoaded$ = new Subject<{ id: string, module: NgModuleRef<any> }>();\r\n  public pluginUnloaded$ = new Subject<string>();\r\n  startLoadPlugin() {\r\n    throw new Error('MockPluginRegistry does not support loading/unloading');\r\n  }\r\n  startUnloadPlugin() {\r\n    throw new Error('MockPluginRegistry does not support loading/unloading');\r\n  }\r\n}\r\n\r\n/**\r\n * This class automates the loading of bundles built with ng-packagr,\r\n * registering the components with GoldenLayout\r\n * This service MUST be instantiated once per window and defines the 'public'\r\n * API for loading and unloading plugins.\r\n */\r\n@Injectable()\r\nexport class PluginRegistryService {\r\n  private availableDependencies = new Map<string, any>();\r\n  private loadedPlugins = new Map<string, IPluginState>();\r\n\r\n  public pluginLoaded$ = new Subject<{ id: string, module: NgModuleRef<any> }>();\r\n  public pluginUnloaded$ = new Subject<string>();\r\n\r\n  constructor(\r\n    @Inject(GoldenLayoutPluginDependency) @Optional() deps: PluginDependencyType[] = [],\r\n    private urlProvider: PluginURLProvider,\r\n    private injector: Injector,\r\n  ) {\r\n    console.log('Creating PluginRegistry, got', deps.length, 'additional dependency modules');\r\n    deps.forEach(x => this.availableDependencies.set(x.name, x.loader));\r\n\r\n    this.patchWindow();\r\n\r\n    this.urlProvider.loadRequests$().subscribe(p => this.load(p));\r\n    // Load all previously loaded plugins\r\n    this.urlProvider.allPlugins().forEach(p => this.load(p));\r\n  }\r\n\r\n  startLoadPlugin(id: string, url: string) {\r\n    this.urlProvider.requestLoad(id, url);\r\n  }\r\n  startUnloadPlugin(id: string) {\r\n    this.urlProvider.requestUnload(id);\r\n  }\r\n\r\n  waitForPlugin(id: string): Promise<any> {\r\n    const p = this.loadedPlugins.get(id);\r\n    if (p) {\r\n      return p.module.promise;\r\n    }\r\n\r\n    const newPlugin: IPluginState = {\r\n      id: id,\r\n      module: new Deferred<any>(),\r\n      url: null,\r\n      script: null,\r\n      moduleRef: null,\r\n    };\r\n    this.loadedPlugins.set(id, newPlugin);\r\n    return newPlugin.module.promise;\r\n  }\r\n\r\n  private patchWindow() {\r\n    (window as any).define = (moduleId: string, deps: string[], factory: (exports: any, ...deps: any[]) => void) => {\r\n      const x = this.loadedPlugins.get(moduleId);\r\n      if (!x) {\r\n        console.warn('Unknown plugin called define():', moduleId);\r\n        return;\r\n      }\r\n\r\n      // first param is exports\r\n      deps = deps.slice(1);\r\n\r\n      const depsExports = deps.map(d => {\r\n        const p = this.availableDependencies.get(d);\r\n        if (!p) {\r\n          console.warn('Plugin', moduleId, 'requested unknown dependency', d);\r\n          return Promise.resolve(undefined);\r\n        }\r\n        const promisifiedP = Promise.resolve(p);\r\n        return promisifiedP.catch(err => {\r\n          console.warn('Plugin', moduleId, 'dependency', d, 'but load failed', err);\r\n          return undefined;\r\n        });\r\n      });\r\n      Promise.all(depsExports).then(deps => {\r\n        const exports: any = {};\r\n        factory(exports, ...deps);\r\n        console.log('Plugin', moduleId, 'loaded.');\r\n        const moduleKlass = exports.MODULE;\r\n        if (!moduleKlass) {\r\n          return Promise.reject(\"No MODULE export found\");\r\n        }\r\n        const moduleFactory = new ÉµNgModuleFactory(moduleKlass);\r\n        x.moduleRef = moduleFactory.create(this.injector);\r\n        x.module.resolve(exports as any);\r\n        this.pluginLoaded$.next({ id: x.id, module: x.moduleRef });\r\n      }).catch(err => {\r\n        console.warn('Failed to load plugin', moduleId, 'error', err);\r\n        x.module.reject(err);\r\n      });\r\n    };\r\n    (window as any).define.amd = true;\r\n    console.log('Window AMD shim established.');\r\n  }\r\n\r\n  private load({ id, url }: IPluginURL) {\r\n    let p = this.loadedPlugins.get(id);\r\n\r\n    // plugin is already loaded or in progress.\r\n    if (p && p.url) {\r\n      if (p.url !== url) {\r\n        throw new Error(\"Plugin is already loaded with another URL\");\r\n      }\r\n      return;\r\n    }\r\n\r\n    // !p means that p is not acitvely being waited on, so create it.\r\n    // if p is defined here it means that component construction actively\r\n    // waits on the loading of this plugin, so we don't need to recreate\r\n    // the structure here.\r\n    if (!p) {\r\n      p = {\r\n        id: id,\r\n        module: new Deferred<any>(),\r\n        url: null,\r\n        moduleRef: null,\r\n        script: null,\r\n      };\r\n    }\r\n\r\n    // Start the actual loading process\r\n    p.url = url;\r\n    this.loadedPlugins.set(id, p);\r\n\r\n    const script = document.createElement('script');\r\n    script.onerror = (e) => p.module.reject(e as any);\r\n    script.type = 'text/javascript';\r\n    script.src = url;\r\n    p.script = script;\r\n\r\n    document.body.appendChild(script);\r\n  }\r\n\r\n  private unload(id: string) {\r\n    // TBD\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nexport const GoldenLayoutContainer = new InjectionToken('GoldenLayoutContainer');\r\nexport const GoldenLayoutComponentState = new InjectionToken('GoldenLayoutComponentState');\r\nexport const GoldenLayoutEventHub = new InjectionToken('GoldenLayoutEventHub');\r\nexport const GoldenLayoutComponentHost = new InjectionToken('GoldenLayoutComponentHost');\r\n","import { GlOnResize, GlOnShow, GlOnHide, GlOnTab, GlOnClose, GlOnPopin, GlOnUnload, GlOnPopout, GlHeaderItem } from \"./hooks\";\r\n\r\n/**\r\n * Type guard which determines if a component implements the GlOnResize interface.\r\n */\r\nexport function implementsGlOnResize(obj: any): obj is GlOnResize {\r\n  return typeof obj === 'object' && typeof obj.glOnResize === 'function';\r\n}\r\n\r\n/**\r\n * Type guard which determines if a component implements the GlOnShow interface.\r\n */\r\nexport function implementsGlOnShow(obj: any): obj is GlOnShow {\r\n  return typeof obj === 'object' && typeof obj.glOnShow === 'function';\r\n}\r\n\r\n/**\r\n * Type guard which determines if a component implements the GlOnHide interface.\r\n */\r\nexport function implementsGlOnHide(obj: any): obj is GlOnHide {\r\n  return typeof obj === 'object' && typeof obj.glOnHide === 'function';\r\n}\r\n\r\n/**\r\n * Type guard which determines if a component implements the GlOnTab interface.\r\n */\r\nexport function implementsGlOnTab(obj: any): obj is GlOnTab {\r\n  return typeof obj === 'object' && typeof obj.glOnTab === 'function';\r\n}\r\n\r\n/**\r\n * Type guard which determines if a component implements the GlOnClose interface.\r\n */\r\nexport function implementsGlOnClose(obj: any): obj is GlOnClose {\r\n  return typeof obj === 'object' && typeof obj.glOnClose === 'function';\r\n}\r\n\r\nexport function implementsGlOnPopin(obj: any): obj is GlOnPopin {\r\n  return typeof obj === 'object' && typeof obj.glOnPopin === 'function';\r\n}\r\nexport function implementsGlOnUnload(obj: any): obj is GlOnUnload {\r\n  return typeof obj === 'object' && typeof obj.glOnUnload === 'function';\r\n}\r\nexport function implementsGlOnPopout(obj: any): obj is GlOnPopout {\r\n  return typeof obj === 'object' && typeof obj.glOnPopout === 'function';\r\n}\r\nexport function implementsGlHeaderItem(obj: any): obj is GlHeaderItem {\r\n  return typeof obj === 'object' && typeof obj.headerComponent === 'function';\r\n}\r\n\r\nexport const uuid = () => {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n    return v.toString(16);\r\n  });\r\n}\r\n","import { Component, ViewEncapsulation, Inject, OnInit, ComponentRef, OnDestroy } from '@angular/core';\r\nimport { GlHeaderItem, GlOnHide, GlOnShow, GlOnResize, GlOnTab } from './hooks';\r\nimport { GoldenLayoutComponentHost, GoldenLayoutComponentState, GoldenLayoutContainer } from './tokens';\r\nimport { implementsGlOnResize, implementsGlOnHide, implementsGlOnShow, implementsGlOnTab } from './type-guards';\r\n\r\n@Component({\r\n  selector: 'gl-wrapper',\r\n  encapsulation: ViewEncapsulation.None,\r\n  template: `<div class=\"wrapper\"></div>`\r\n})\r\nexport class WrapperComponent implements\r\n  GlHeaderItem,\r\n  OnInit,\r\n  OnDestroy,\r\n  GlOnHide,\r\n  GlOnShow,\r\n  GlOnResize,\r\n  GlOnTab\r\n {\r\n  get headerComponent() {\r\n    if (!this.originalComponent || !this.originalComponent.instance) {\r\n      return undefined;\r\n    }\r\n    return this.originalComponent.instance.then(x => x.instance.headerComponent);\r\n  }\r\n  get additionalTokens() {\r\n    if (!this.originalComponent || !this.originalComponent.instance) {\r\n      return undefined;\r\n    }\r\n    return this.originalComponent.instance.then(x => x.instance.additionalTokens);\r\n  }\r\n\r\n  private originalComponent: any;\r\n  private destroyed = false;\r\n  private initialized = false;\r\n\r\n  constructor(\r\n    @Inject(GoldenLayoutComponentHost) private host: any,\r\n    @Inject(GoldenLayoutContainer) private container: any,\r\n    @Inject(GoldenLayoutComponentState) private state: any,\r\n  ) {\r\n    this.originalComponent = (this.host.getGoldenLayoutInstance() as any)._getAllComponents()[this.state.originalId];\r\n  }\r\n\r\n\r\n  ngOnInit() {\r\n    this.originalComponent.instance.then((componentRef: ComponentRef<any>) => {\r\n      if (this.destroyed || this.initialized) {\r\n        return;\r\n      }\r\n      this.redock(componentRef, this.container.getElement());\r\n      this.initialized = true;\r\n    })\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.originalComponent.instance.then((cr: ComponentRef<any>) => {\r\n      if (!this.initialized || this.destroyed) {\r\n        return;\r\n      }\r\n      this.redock(cr, this.originalComponent.container.getElement());\r\n      this.destroyed = true;\r\n    })\r\n  }\r\n\r\n  private redock(componentRef: ComponentRef<any>, to: JQuery) {\r\n    const el = $(componentRef.location.nativeElement);\r\n    el.remove();\r\n    to.append(el);\r\n    if (implementsGlOnResize(componentRef.instance)) {\r\n      componentRef.instance.glOnResize();\r\n    }\r\n  }\r\n\r\n  glOnHide() {\r\n    this.originalComponent.instance.then((cr: ComponentRef<any>) => {\r\n      if (implementsGlOnHide(cr.instance)) {\r\n        cr.instance.glOnHide();\r\n      }\r\n    });\r\n  }\r\n  glOnShow() {\r\n    this.originalComponent.instance.then((cr: ComponentRef<any>) => {\r\n      if (implementsGlOnShow(cr.instance)) {\r\n        cr.instance.glOnShow();\r\n      }\r\n    });\r\n  }\r\n  glOnResize() {\r\n    this.originalComponent.instance.then((cr: ComponentRef<any>) => {\r\n      if (implementsGlOnResize(cr.instance)) {\r\n        cr.instance.glOnResize();\r\n      }\r\n    });\r\n  }\r\n  glOnTab(tab: any) {\r\n    this.originalComponent.instance.then((cr: ComponentRef<any>) => {\r\n      if (implementsGlOnTab(cr.instance)) {\r\n        debugger;\r\n        cr.instance.glOnTab(this.originalComponent.tab);\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { Inject, Injectable, Optional, Type } from '@angular/core';\r\nimport { ComponentType, GoldenLayoutComponents } from './config';\r\nimport { PluginRegistryService } from './plugin-registry.service';\r\nimport { Deferred } from './deferred';\r\nimport { WrapperComponent } from './wrapper.component';\r\n\r\n@Injectable()\r\nexport class ComponentRegistryService {\r\n  private components = new Map<string, Type<any>>();\r\n  private awaitedComponents = new Map<string, Deferred<Type<any>>>();\r\n\r\n  constructor(\r\n    @Inject(GoldenLayoutComponents) @Optional() initialComponents?: ComponentType[],\r\n    @Optional() private pluginRegistry?: PluginRegistryService,\r\n  ) {\r\n    (initialComponents || []).forEach(c => this.registerComponent(c));\r\n    this.registerComponent({\r\n      name: 'gl-wrapper',\r\n      type: WrapperComponent,\r\n    });\r\n\r\n    this.pluginRegistry?.pluginLoaded$.subscribe(({ id, module }) => {\r\n      const registeredTokens = module.injector.get(GoldenLayoutComponents, []);\r\n      console.log('Plugin', id, 'wants to register', registeredTokens.length, 'components');\r\n      registeredTokens.forEach(c => this.registerComponent({ ...c, plugin: id }));\r\n    });\r\n  }\r\n\r\n  public registeredComponents(): ComponentType[] {\r\n    return [...this.components.entries()].map((e): ComponentType => ({ name: e[0], type: e[1] }));\r\n  }\r\n\r\n  // This is only for use by the GoldenLayoutComponent\r\n  public componentMap(): Map<string, Type<any>> {\r\n      return this.components;\r\n  }\r\n\r\n  public registerComponent(component: ComponentType) {\r\n    const otherComponent = this.components.get(component.name);\r\n    if (!!otherComponent && otherComponent !== component.type) {\r\n      const err = new Error(`Failed to register component, ${component.name} is already taken by another component: ${otherComponent}`);\r\n      throw err;\r\n    }\r\n    this.components.set(component.name, component.type);\r\n    const d = this.awaitedComponents.get(component.name);\r\n    if (d) {\r\n      this.awaitedComponents.delete(component.name);\r\n      d.resolve(component.type);\r\n    }\r\n  }\r\n\r\n  public waitForComponent(component: string): Promise<Type<any>> {\r\n    const c = this.components.get(component);\r\n    if (c) {\r\n      return Promise.resolve(c);\r\n    }\r\n\r\n    let d = this.awaitedComponents.get(component);\r\n    if (!d) {\r\n      d = new Deferred<Type<any>>();\r\n      this.awaitedComponents.set(component, d);\r\n    }\r\n    return d.promise;\r\n  }\r\n}\r\n","import { InjectionToken, Type } from '@angular/core';\r\n\r\n/**\r\n * Inject an angular component using this token to indicate\r\n * that the component should be rendered when there is an error rendering\r\n * the actual component.\r\n * Errors could be exceptions thrown at construction time or a not-registered component.\r\n */\r\nexport const FallbackComponent = new InjectionToken<Type<any>>(\"fallback component\");\r\n\r\n/**\r\n * This token is injected into the FallbackComponent when it is instantiated and contains\r\n * the name of the component that failed to initialize.\r\n */\r\nexport const FailedComponent = new InjectionToken<string>(\"failed component\");\r\n","import { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class RootWindowService {\r\n\r\n  constructor() {}\r\n\r\n  public isChildWindow(): boolean {\r\n    try {\r\n      return !!window.opener && !!window.opener.location.href;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  public getRootWindow(): Window & typeof globalThis {\r\n    return this.isChildWindow() ? window.opener : window;\r\n  }\r\n}\r\n","import { Injectable, ApplicationRef, Injector } from '@angular/core';\r\nimport { RootWindowService } from './root-window.service';\r\n\r\n@Injectable()\r\nexport class MockWindowSynchronizerService {\r\n  restoreAppRefTick() {}\r\n  onUnload() {}\r\n}\r\n\r\n@Injectable()\r\nexport class WindowSynchronizerService {\r\n  private topWindow: Window & typeof globalThis;\r\n  private isChildWindow: boolean;\r\n  private unloaded = false;\r\n\r\n  constructor(\r\n    private appref: ApplicationRef,\r\n    private rootService: RootWindowService,\r\n    private injector: Injector,\r\n  ) {\r\n    this.topWindow = this.rootService.getRootWindow();\r\n    this.isChildWindow = this.rootService.isChildWindow();\r\n\r\n    if (this.isChildWindow) {\r\n      window.document.title = window.document.URL;\r\n      (console as any).__log = console.log;\r\n      console.log = (...args: any[]) => this.topWindow.console.log('[CHILD] =>', ...args);\r\n    }\r\n\r\n    // Multi-Window compatibility.\r\n    // We need to synchronize all appRefs that could tick\r\n    // Store them in a global array and also overwrite the injector using the injector from the main window.\r\n    let anyWin = this.topWindow as any;\r\n    if (!this.isChildWindow) {\r\n      anyWin.__apprefs = [];\r\n      anyWin.__injector = this.injector;\r\n    }\r\n\r\n    // attach the application reference to the root window, save the original 'tick' method\r\n    anyWin.__apprefs.push(this.appref);\r\n    (this.appref as any).__tick = this.appref.tick;\r\n\r\n    // Overwrite the tick method running all apprefs in their zones.\r\n    this.appref.tick = (): void => {\r\n      for (const ar of (this.topWindow as any).__apprefs) {\r\n        ar._zone.run(() => ar.__tick());\r\n      }\r\n    };\r\n  }\r\n\r\n  public restoreAppRefTick() {\r\n    this.appref.tick = (this.appref as any).__tick;\r\n  }\r\n\r\n  public onUnload() {\r\n    if (this.unloaded) {\r\n      return;\r\n    }\r\n    this.unloaded = true;\r\n    if (this.isChildWindow) {\r\n      const index = (this.topWindow as any).__apprefs.indexOf(this.appref);\r\n      if (index >= 0) {\r\n        (this.topWindow as any).__apprefs.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  isDevMode,\r\n  ComponentFactoryResolver,\r\n  HostListener,\r\n  ViewContainerRef,\r\n  ElementRef,\r\n  Component,\r\n  OnInit,\r\n  OnDestroy,\r\n  ApplicationRef,\r\n  Optional,\r\n  Inject,\r\n  NgZone,\r\n  Injector,\r\n  ViewChild,\r\n  Input,\r\n  Output,\r\n  EventEmitter,\r\n  StaticProvider,\r\n  Type,\r\n  ComponentRef,\r\n  SkipSelf,\r\n} from '@angular/core';\r\nimport * as GoldenLayout from 'golden-layout';\r\nimport { ComponentRegistryService } from './component-registry.service';\r\nimport { FallbackComponent, FailedComponent } from './fallback';\r\nimport { RootWindowService } from './root-window.service';\r\nimport { Observable, Subscription, BehaviorSubject, of, Subject } from 'rxjs';\r\nimport { switchMap, takeUntil, distinctUntilChanged } from 'rxjs/operators';\r\nimport {\r\n  implementsGlOnResize,\r\n  implementsGlOnShow,\r\n  implementsGlOnHide,\r\n  implementsGlOnTab,\r\n  implementsGlOnClose,\r\n  implementsGlOnPopin,\r\n  implementsGlOnUnload,\r\n  implementsGlOnPopout,\r\n  uuid,\r\n} from './type-guards';\r\nimport { Deferred } from './deferred';\r\nimport { WindowSynchronizerService } from './window-sync.service';\r\nimport {\r\n  GoldenLayoutContainer,\r\n  GoldenLayoutComponentState,\r\n  GoldenLayoutEventHub,\r\n  GoldenLayoutComponentHost\r\n} from './tokens';\r\nimport { IExtendedGoldenLayoutConfig } from './config';\r\n\r\ninterface ComponentInitCallback extends Function {\r\n  (container: GoldenLayout.Container, componentState: any): void;\r\n}\r\n\r\n// We need to wrap some golden layout internals, so we can intercept close and 'close stack'\r\n// For close, the tab is wrapped and the close element to change the event handler to close the correct container.\r\nconst lm = GoldenLayout as any;\r\nconst isCloned = (contentItem: GoldenLayout.ContentItem) => contentItem.isComponent &&\r\ncontentItem.config &&\r\n(contentItem.config as GoldenLayout.ComponentConfig).componentState &&\r\n(contentItem.config as GoldenLayout.ComponentConfig).componentState.originalId;\r\n\r\nexport const GetComponentFromLayoutManager = (lm: GoldenLayout, id: string): GoldenLayout.ContentItem => {\r\n  const itemList = lm.root.getItemsById(id);\r\n  if (itemList.length !== 1) {\r\n    console.warn('non unique ID found: ' + id);\r\n    return undefined;\r\n  }\r\n  return itemList[0];\r\n};\r\nconst originalComponent = (contentItem: GoldenLayout.ContentItem): any => {\r\n  const comp = GetComponentFromLayoutManager(\r\n    contentItem.layoutManager,\r\n    (contentItem.config as GoldenLayout.ComponentConfig).componentState.originalId,\r\n  );\r\n  if (!comp.isComponent) {\r\n    throw new Error('Expected component');\r\n  }\r\n  return comp;\r\n};\r\nconst tabFromId = (contentItem: GoldenLayout.ContentItem) => {\r\n  const ci = originalComponent(contentItem);\r\n  return ci ? ci.tab : undefined;\r\n};\r\n// This code wraps the original golden-layout Tab\r\n// A tab is instantiated by the golden-layout Header\r\n// We rebind the close event listener to properly dispose the angular item container\r\n// In order to destroy the angular component ref and be able to defer the close.\r\nconst originalTab = lm.__lm.controls.Tab;\r\nconst newTab = function(header, tabContentItem) {\r\n  const tab = new originalTab(header, tabContentItem);\r\n\r\n  /**\r\n   * This piece of code implements close functionality for the tab close.\r\n   * If we have a cloned tab, i.e. one which is contained in a maximised dummy stack\r\n   * we close the container backing the tab.\r\n   */\r\n  tab.closeElement.off('click touchstart');\r\n  tab.closeElement.on('click touchstart', (ev) => {\r\n    ev.stopPropagation();\r\n    if (isCloned(tab.contentItem)) {\r\n      const c = originalComponent(tab.contentItem);\r\n      if (c && c.isComponent) {\r\n        // If we have a dummy tab, close the actual tab behind it.\r\n        c.container.close();\r\n      }\r\n    } else {\r\n      // Otherwise close our own tab.\r\n      tab.contentItem.container.close();\r\n    }\r\n  });\r\n\r\n  /**\r\n   * This script emits a tabActivated event for the correct content item\r\n   * when running in a maximised dummy stack.\r\n   */\r\n  tab.element.on('mousedown touchstart', ev => {\r\n    let contentItem = tab.contentItem;\r\n    if (isCloned(contentItem)) {\r\n      contentItem = originalComponent(tab.contentItem);\r\n    }\r\n    contentItem.layoutManager.emit('tabActivated', contentItem);\r\n  });\r\n\r\n  if (isCloned(tab.contentItem) && tab._layoutManager.config.settings.reorderEnabled === true) {\r\n    // Reimplement tab drag start by redirecting the tab state.\r\n    tab.element.on('mousedown touchstart', (ev) => {\r\n      const originalTab = tabFromId(tab.contentItem);\r\n      if (originalTab && originalTab._dragListener) {\r\n        const dl = originalTab._dragListener;\r\n        const destroyDummy = () => {\r\n          dl.off('dragStart', destroyDummy, dl);\r\n          if (header.layoutManager._maximisedItem === tab.contentItem.parent) {\r\n            tab.contentItem.parent.toggleMaximise();\r\n          }\r\n        };\r\n        dl.off('dragStart', originalTab._onDragStart, originalTab);\r\n        dl.on('dragStart', destroyDummy, dl);\r\n        dl.on('dragStart', originalTab._onDragStart, originalTab);\r\n        dl._fDown(ev);\r\n      }\r\n    });\r\n  }\r\n  return tab;\r\n};\r\nnewTab._template = '<li class=\"lm_tab\"><i class=\"lm_left\"></i>' +\r\n'<span class=\"lm_title\"></span><div class=\"lm_close_tab\"></div>' +\r\n'<i class=\"lm_right\"></i></li>';\r\nlm.__lm.controls.Tab = newTab;\r\n\r\n\r\n// Header is wrapped to catch the maximise and close buttons.\r\nconst originalHeader = lm.__lm.controls.Header;\r\nconst newHeader = function(layoutManager, parent) {\r\n  const maximise = parent._header['maximise'];\r\n  const popout = parent._header['popout'];\r\n  if (maximise && layoutManager.config.settings.maximiseAllItems === true) {\r\n    // Check whether we should maximise all stacks and if so, force the header to\r\n    // not generate a maximise button.\r\n    delete parent._header['maximise'];\r\n  }\r\n  if (popout && layoutManager.config.settings.maximiseAllItems === true) {\r\n    delete parent._header['popout'];\r\n  }\r\n\r\n  // Generate the original header\r\n  const header = new originalHeader(layoutManager, parent);\r\n\r\n  // Check whether we should maximise all stacks, and if so, generate a custom popout button\r\n  // but keep the order with the maximise and close button\r\n  if (popout && layoutManager.config.settings.maximiseAllItems === true) {\r\n    header.popoutButton = new lm.__lm.controls.HeaderButton(header, popout, 'lm_popout', () => {\r\n      let contentItem = header.activeContentItem;\r\n      if (isCloned(contentItem)) {\r\n        // We are within the dummy stack, our component is a wrapper component\r\n        // and has a reference to the original (= wrapped) component.\r\n        // Therefore, popping out the whole stack would be stupid, because it wouldn't leave\r\n        // any item in this window.\r\n        contentItem = originalComponent(contentItem);\r\n        contentItem.popout();\r\n      } else if (layoutManager.config.settings.popoutWholeStack === true) {\r\n        // We have a regular stack, so honor the popoutWholeStack setting.\r\n        header.parent.popout();\r\n      } else {\r\n        contentItem.popout();\r\n      }\r\n    });\r\n  }\r\n\r\n  // Check whether we should maximise all stacks, and if so, generate a custom maximise button\r\n  // but keep the order with the close button.\r\n  if (maximise && layoutManager.config.settings.maximiseAllItems === true) {\r\n    header.maximiseButton = new lm.__lm.controls.HeaderButton(header, maximise, 'lm_maximise', () => {\r\n      // The maximise button was clicked, so create a dummy stack, containing a wrapper component for each opened component.\r\n      if (layoutManager._maximisedItem === parent) {\r\n        parent.toggleMaximise();\r\n      } else {\r\n        layoutManager.generateAndMaximiseDummyStack(parent);\r\n      }\r\n    });\r\n  }\r\n  if (header.closeButton) {\r\n    header.closeButton._$destroy();\r\n    const label = header._getHeaderSetting('close');\r\n    header.closeButton = new lm.__lm.controls.HeaderButton(header, label, 'lm_close', () => {\r\n      header.parent.contentItems.forEach(ci => {\r\n        ci.container.close();\r\n      });\r\n    });\r\n  }\r\n  return header;\r\n};\r\nnewHeader._template = [\r\n\t'<div class=\"lm_header\">',\r\n\t'<ul class=\"lm_tabs\"></ul>',\r\n\t'<ul class=\"lm_controls\"></ul>',\r\n\t'<ul class=\"lm_tabdropdown_list\"></ul>',\r\n\t'</div>'\r\n].join( '' );\r\nlm.__lm.controls.Header = newHeader;\r\n\r\n\r\n// Patch the drag proxy in order to have an itemDragged event.\r\nconst origDragProxy = lm.__lm.controls.DragProxy;\r\nconst dragProxy = function(x, y, dragListener, layoutManager, contentItem, originalParent) {\r\n  layoutManager.emit('itemDragged', contentItem);\r\n  return new origDragProxy(x, y, dragListener, layoutManager, contentItem, originalParent);\r\n}\r\ndragProxy._template = origDragProxy._template;\r\nlm.__lm.controls.DragProxy = dragProxy;\r\n\r\n// Patch the stack in order to have an activeContentItemChanged$ observable\r\nconst origStack = lm.__lm.items.Stack;\r\nfunction MyStack(lm, config, parent) {\r\n  origStack.call(this, lm, config, parent);\r\n  this.activeContentItem$ = new BehaviorSubject<any>(null);\r\n  const callback = (ci) => {\r\n    if (this.activeContentItem$) {\r\n      this.activeContentItem$.next(ci)\r\n    };\r\n  };\r\n  this.on('activeContentItemChanged', callback);\r\n  const origDestroy = this._$destroy;\r\n  this.___destroyed = false;\r\n  this._$destroy = () => {\r\n    if (this.___destroyed) {\r\n      return;\r\n    }\r\n    this.___destroyed = true;\r\n    this.off('activeContentItemChanged', callback);\r\n    this.activeContentItem$.complete();\r\n    this.activeContentItem$ = null;\r\n    origDestroy.call(this);\r\n  };\r\n  return this;\r\n}\r\nMyStack.prototype = Object.create(origStack.prototype);\r\n\r\n// Force stacks to be flattened.\r\nMyStack.prototype['addChild'] = function(contentItem: GoldenLayout.ItemConfig, index: number) {\r\n  if (contentItem.type === 'stack') {\r\n    // We try to pop in a stack into another stack (i.e. nested tab controls.)\r\n    // This breaks the other stuff in custom header components, therefore it's not recommended.\r\n    // So we add the items directly into this stack.\r\n    (contentItem.content || []).forEach((ci, idx) => origStack.prototype.addChild.call(this, ci, index + idx));\r\n    if (contentItem.content.length) {\r\n      this.setActiveContentItem(this.contentItems[index + (contentItem as any).activeItemIndex]);\r\n    }\r\n  } else {\r\n    origStack.prototype.addChild.call(this, contentItem, index);\r\n  }\r\n};\r\nMyStack.prototype['setSize'] = function() {\r\n  if (this.layoutManager._maximisedItem === this && this.layoutManager.config.settings.maximiseAllItems === true) {\r\n    // Actually enforce that this item will be the correct size\r\n    this.element.width(this.layoutManager.container.width());\r\n    this.element.height(this.layoutManager.container.height());\r\n  }\r\n  origStack.prototype.setSize.call(this);\r\n};\r\nlm.__lm.items.Stack = MyStack;\r\n\r\nconst origPopout = lm.__lm.controls.BrowserPopout;\r\nconst popout = function(config: GoldenLayout.ItemConfig[], dimensions, parent, index, lm) {\r\n  if (config.length !== 1) {\r\n    console.warn('This should not happen, permitting', config);\r\n  } else {\r\n    if (config[0].type === 'component') {\r\n      config = [{\r\n        type: 'stack',\r\n        title: config[0].title, // Required for adjustToWindowMode to work. (Line 1282 in 1.5.9)\r\n        content: [config[0]],\r\n      }];\r\n    }\r\n  }\r\n  return new origPopout(config, dimensions, parent, index, lm);\r\n};\r\nlm.__lm.controls.BrowserPopout = popout;\r\n\r\n\r\n// Fixup for nested golden-layout instances.\r\n// nested instances should be able to be docked out completely\r\n// but the golden layout will recognize its query string and be incorrectly nested.\r\nconst getQueryStringParam = lm.__lm.utils.getQueryStringParam;\r\nlet firstQueryString = true;\r\nlm.__lm.utils.getQueryStringParam = (param: string) => {\r\n  if (firstQueryString) {\r\n    firstQueryString = false;\r\n    return getQueryStringParam(param);\r\n  }\r\n  return null;\r\n}\r\n@Component({\r\n  selector: 'golden-layout-root',\r\n  styles: [`\r\n    .ng-golden-layout-root {\r\n      width:100%;\r\n      height:100%;\r\n    }`\r\n  ],\r\n  template: `<div class=\"ng-golden-layout-root\" #glroot></div>`\r\n})\r\nexport class GoldenLayoutComponent implements OnInit, OnDestroy {\r\n\r\n  @Input() layout: Observable<IExtendedGoldenLayoutConfig>;\r\n  @Output() stateChanged = new EventEmitter<never>();\r\n  @Output() tabActivated = new EventEmitter<GoldenLayout.ContentItem>();\r\n\r\n  @ViewChild('glroot', { static: true }) private el: ElementRef;\r\n\r\n  private goldenLayout: GoldenLayout = null;\r\n  private onUnloaded = new Deferred<void>();\r\n  private stateChangePaused = false;\r\n  private stateChangeScheduled = false;\r\n  private tabsList = new BehaviorSubject<{ [tabId: string]: GoldenLayout.ContentItem }>({});\r\n  pushStateChange = () => {\r\n    // For each state change, we want to refresh the list of the opened components. At the moment, we only care about the keys.\r\n    this.tabsList.next((this.goldenLayout as any)._getAllComponents());\r\n    if (this.stateChangePaused || this.stateChangeScheduled) {\r\n      return;\r\n    }\r\n    this.stateChangeScheduled = true;\r\n    window.requestAnimationFrame(() => {\r\n      this.stateChangeScheduled = false;\r\n      this.stateChanged.emit()\r\n    });\r\n  };\r\n\r\n  resumeStateChange = () => this.stateChangePaused = false;\r\n  pauseStateChange = () => this.stateChangePaused = true;\r\n  pushTabActivated = (ci: GoldenLayout.ContentItem) => {\r\n    this.tabActivated.emit(ci);\r\n  }\r\n\r\n  private fallbackType: ComponentInitCallback = null;\r\n  private layoutSubscription: Subscription;\r\n  private openedComponents = [];\r\n  private poppedIn = false;\r\n  private _eventEmitter = new lm.__lm.utils.EventEmitter();\r\n\r\n  @HostListener('window:resize')\r\n  public onResize(): void {\r\n    if (this.goldenLayout) {\r\n      this.goldenLayout.updateSize();\r\n    }\r\n  }\r\n\r\n  constructor(\r\n    private rootService: RootWindowService,\r\n    private componentRegistry: ComponentRegistryService,\r\n    private viewContainer: ViewContainerRef,\r\n    private componentFactoryResolver: ComponentFactoryResolver,\r\n    private ngZone: NgZone,\r\n    private readonly injector: Injector,\r\n    private windowSync: WindowSynchronizerService,\r\n    @Optional() @SkipSelf() private parentGoldenLayout: GoldenLayoutComponent,\r\n    @Optional() @Inject(FallbackComponent) private readonly fallbackComponent: any\r\n  ) {\r\n    console.log(parentGoldenLayout);\r\n    if (!!this.fallbackComponent) {\r\n      this.fallbackType = this.buildConstructor(this.fallbackComponent);\r\n    }\r\n\r\n    if (isDevMode()) console.log(`Create@${this.rootService.isChildWindow ? 'child' : 'root'}!`);\r\n  }\r\n\r\n  public ngOnInit(): void {\r\n    if (isDevMode()) console.log(`Init@${this.rootService.isChildWindow ? 'child' : 'root'}!`);\r\n\r\n    this.layoutSubscription = this.layout.subscribe(layout => {\r\n      this.destroyGoldenLayout();\r\n      this.initializeGoldenLayout(layout);\r\n    });\r\n  }\r\n  // Map beforeunload to onDestroy to simplify the handling\r\n  @HostListener('window:beforeunload')\r\n  public beforeUnload() {\r\n    if (this.poppedIn) {\r\n      this.onUnloaded.promise.then(() => this.ngOnDestroy());\r\n      this.onUnloaded.resolve();\r\n      this.windowSync.onUnload();\r\n    }\r\n  }\r\n\r\n  // Map beforeunload to onDestroy to simplify the handling\r\n  @HostListener('window:pagehide')\r\n  public pageHide() {\r\n    if (!this.poppedIn) {\r\n      this.openedComponents.forEach(c => {\r\n        if (implementsGlOnUnload(c)) {\r\n          c.glOnUnload();\r\n        }\r\n      });\r\n    }\r\n    this.onUnloaded.promise.then(() => this.ngOnDestroy());\r\n    this.onUnloaded.resolve();\r\n    this.windowSync.onUnload();\r\n  }\r\n\r\n  public ngOnDestroy(): void {\r\n    if (isDevMode()) {\r\n      console.log(`Destroy@${this.rootService.isChildWindow ? 'child' : 'root'}!`);\r\n    }\r\n    this.layoutSubscription.unsubscribe();\r\n\r\n    // restore the original tick method.\r\n    // this appens in two cases:\r\n    // either the window is closed, after that it's not important to restore the tick method\r\n    // or within the root window, where we HAVE to restore the original tick method\r\n    this.windowSync.restoreAppRefTick();\r\n    this.destroyGoldenLayout();\r\n    // Discard all previously made subscriptions.\r\n    this._eventEmitter._mSubscriptions = { [lm.__lm.utils.EventEmitter.ALL_EVENT]: [] };\r\n  }\r\n\r\n  public getGoldenLayoutInstance(): GoldenLayout {\r\n    if (!this.goldenLayout) {\r\n      throw new Error('Component is not initialized yet');\r\n    }\r\n    return this.goldenLayout;\r\n  }\r\n\r\n  public addEvent(kind: string, callback: Function, context?: any) {\r\n    this._eventEmitter.on(kind, callback, context);\r\n  }\r\n\r\n  public getSerializableState(): any {\r\n    if (this.goldenLayout) {\r\n      const configObj = this.goldenLayout.toConfig();\r\n      const wrapperMax = (this.goldenLayout as any).__wrapperMaximisedItemId;\r\n      if (wrapperMax) {\r\n        configObj.maximisedItemId = wrapperMax;\r\n        const filterContent = (ci) => {\r\n          if (ci.type === 'stack' && ci.isDummy) {\r\n            return false;\r\n          }\r\n          if (ci.type !== 'component') {\r\n            ci.content = ci.content.filter(filterContent);\r\n          }\r\n          return true;\r\n        }\r\n        configObj.content = configObj.content.filter(filterContent);\r\n      }\r\n      return configObj;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public getComponents(): { [id: string]: GoldenLayout.ContentItem } {\r\n    return (this.goldenLayout as any)._getAllComponents();\r\n  }\r\n\r\n  public closeComponent(component: string) {\r\n    const c = GetComponentFromLayoutManager(this.goldenLayout, component);\r\n    if (!c) {\r\n      return;\r\n    }\r\n    c.remove();\r\n  }\r\n\r\n  public focusComponent(component: string) {\r\n    const c = GetComponentFromLayoutManager(this.goldenLayout, component);\r\n    if (!c) {\r\n      return;\r\n    }\r\n    c.parent.setActiveContentItem(c);\r\n  }\r\n\r\n  public createNewComponent(config: GoldenLayout.ComponentConfig, componentToDock?: string): Promise<ComponentRef<any>> {\r\n    if (!this.goldenLayout) {\r\n      throw new Error(\"golden layout is not initialized\");\r\n    }\r\n    let myConfig: GoldenLayout.ItemConfig = config;\r\n    const root = this.goldenLayout.root;\r\n    let element: GoldenLayout.ContentItem = null;\r\n    if (componentToDock) {\r\n      const c = GetComponentFromLayoutManager(this.goldenLayout, componentToDock);\r\n      if (c.parent.isStack) {\r\n        element = c.parent;\r\n      } else {\r\n        const stack = this.goldenLayout.createContentItem({\r\n          type: 'stack',\r\n          width: c.parent.config.width,\r\n          height: c.parent.config.height,\r\n          content: [],\r\n        }) as any;\r\n        (c.parent.replaceChild as any)(c, stack, false);\r\n        stack.addChild(c);\r\n        element = stack;\r\n      }\r\n    } else {\r\n      if (!root.contentItems || root.contentItems.length === 0) {\r\n        element = root;\r\n        // Ensure there is a stack when closing ALL items and creating a new item.\r\n        myConfig = {\r\n          type: 'stack',\r\n          content: [{\r\n            ...myConfig,\r\n            type: 'component',\r\n          }],\r\n        };\r\n      } else {\r\n        element = this.findStack(root.contentItems);\r\n      }\r\n    }\r\n    if (element === null) {\r\n      throw new Error(\"this should never happen!\");\r\n    }\r\n\r\n    const content = this.goldenLayout.createContentItem(myConfig) as any;\r\n    element.addChild(content);\r\n    if (content.isComponent) {\r\n      // Usually\r\n      return content.instance;\r\n    } else if (content.isStack && content.contentItems.length === 1) {\r\n      return content.contentItems[0].instance; // The case when this is the first component.\r\n    } else {\r\n      return content;\r\n    }\r\n  }\r\n\r\n  private findStack(contentItems: GoldenLayout.ContentItem[]): GoldenLayout.ContentItem {\r\n    if (!contentItems) {\r\n      return null;\r\n    }\r\n    for (const x of contentItems) {\r\n      if (x.isStack) {\r\n        if ((x.config as any).isDummy) {\r\n          continue;\r\n        }\r\n        return x;\r\n      }\r\n      const s = this.findStack(x.contentItems);\r\n      if (s !== null) {\r\n        return s;\r\n      }\r\n    }\r\n  }\r\n\r\n  private destroyGoldenLayout(): void {\r\n    if (!this.goldenLayout) {\r\n      return;\r\n    }\r\n    this.goldenLayout.off('stateChanged', this.pushStateChange);\r\n    this.goldenLayout.off('itemDropped', this.resumeStateChange);\r\n    this.goldenLayout.off('itemDragged', this.pauseStateChange);\r\n    this.goldenLayout.off('tabActivated', this.pushTabActivated);\r\n    this.goldenLayout.off('initialised');\r\n    this.goldenLayout.off(lm.__lm.utils.EventEmitter.ALL_EVENT, this._eventEmitter.emit, this._eventEmitter);\r\n    this.goldenLayout.destroy();\r\n    this.goldenLayout = null;\r\n  }\r\n\r\n  private initializeGoldenLayout(layout: any): void {\r\n    this.goldenLayout = new GoldenLayout(layout, $(this.el.nativeElement));\r\n    const origPopout = this.goldenLayout.createPopout.bind(this.goldenLayout);\r\n    this.goldenLayout.createPopout = (item: GoldenLayout.ContentItem, dim, parent, index) => {\r\n      /**\r\n       * Traverse the component tree below the item we're trying to pop out.\r\n       * This has basically two cases:\r\n       * a) we have a component to popout (or end up at a component somewhen)\r\n       *    for components, contentItems is either undefined or empty, so ignore it\r\n       *    during the children push.\r\n       *    however, for components, we need to check for glOnPopout and call it.\r\n       * b) everything else, where contentItems is a non-empty array.\r\n       *    For these parts, we need to consider all children recursively.\r\n       *\r\n       * Here, an iterative algorithm was chosen.\r\n       */\r\n      const rec = [item];\r\n      while(rec.length) {\r\n        const itemToProcess = rec.shift();\r\n        if (itemToProcess.contentItems && itemToProcess.contentItems.length > 0) {\r\n          rec.push(...itemToProcess.contentItems);\r\n        }\r\n        if (itemToProcess.isComponent) {\r\n          const component = (itemToProcess as any).container.__ngComponent;\r\n          if (component && implementsGlOnPopout(component)) {\r\n            component.glOnPopout();\r\n          }\r\n        }\r\n      }\r\n      return origPopout(item, dim, parent, index);\r\n    }\r\n    /**\r\n     * buildComponentMap creates an object of all opened components below the given item.\r\n     * object keys are component IDs, object values the component with the ID.\r\n     */\r\n    const buildComponentMap = (item: GoldenLayout.ContentItem) => {\r\n      let ret = {};\r\n      for (const ci of item.contentItems) {\r\n        if (ci.isComponent) {\r\n          if (ci.config && (ci.config as any).componentState && (ci.config as any).componentState.originalId) {\r\n            // Skip the dummy components\r\n            continue;\r\n          }\r\n          ret[ci.id] = ci;\r\n        } else {\r\n          ret = { ...ret, ...buildComponentMap(ci) };\r\n        }\r\n      }\r\n      return ret;\r\n    };\r\n    (this.goldenLayout as any)._getAllComponents = () => buildComponentMap(this.goldenLayout.root);\r\n    (this.goldenLayout as any).generateAndMaximiseDummyStack = (parent, item) => {\r\n      /**\r\n       * This function creates a dummy stack, which is being used if 'maximiseAllItems' is true.\r\n       * The dummy stack contains a dummy component for each component opened in the real layout.\r\n       * It will furthermore track component closes/spawns and create/close the dummy components accordingly.\r\n       * parent is the parent of the item we want to maximise\r\n       * item is the item which was active when we wanted to maximise it.\r\n       * required to set the active item index.\r\n       */\r\n      const openedComponents = buildComponentMap(this.goldenLayout.root);\r\n      const componentIdList = Object.keys(openedComponents);\r\n      if (componentIdList.length === 0) {\r\n        return; // How did we get here?!\r\n      }\r\n\r\n      // We only have a single child, so we restore the original behavior\r\n      const rootContentItem = this.goldenLayout.root.contentItems[0];\r\n      if (rootContentItem.isStack) {\r\n        rootContentItem.toggleMaximise();\r\n        return;\r\n      }\r\n\r\n      /**\r\n       * At this point, there are at least two children, so use the dummy component.\r\n       */\r\n      const config = {\r\n        type: 'stack',\r\n        content: componentIdList.map(k => ({\r\n          type: 'component',\r\n          componentName: 'gl-wrapper',\r\n          title: openedComponents[k].config.title,\r\n          reorderEnabled: false,\r\n          componentState: {\r\n            originalId: k, // pass in the ID of the original component as parameter.\r\n          },\r\n        })),\r\n        isClosable: false,\r\n        isDummy: true,\r\n        state: 'dummy',\r\n        activeItemIndex: componentIdList.findIndex(j => j === (item || parent._activeContentItem.id)),\r\n      }\r\n      // add this item as first child ever, causing golden-layout to create a stack object\r\n      rootContentItem.addChild(config, 0);\r\n\r\n      // Fetch the stack\r\n      const myStack = rootContentItem.contentItems[0] as GoldenLayout.ContentItem;\r\n      // Setup an __wrapperMaximisedItemId in order to setActiveContentItem on the underlying stack later.\r\n      (this.goldenLayout as any).__wrapperMaximisedItemId = parent._activeContentItem.id;\r\n      (myStack as any).activeContentItem$.subscribe((ci) => {\r\n        // Setup the __wrapperMaximisedItemId lateron.\r\n        (this.goldenLayout as any).__wrapperMaximisedItemId = ci.config.componentState.originalId;\r\n      });\r\n\r\n      const teardown$ = new Subject();\r\n      myStack.on('minimised', () => {\r\n        // Dummy stack was minimised, so enforce all dummy components to be disposed\r\n        // and dispose the dummy stack as well.\r\n        (this.goldenLayout as any).__wrapperMaximisedItemId = null;\r\n        teardown$.next();\r\n        teardown$.complete();\r\n        myStack.remove()\r\n      });\r\n      // Maximise the dummy stack.\r\n      myStack.toggleMaximise();\r\n\r\n      // Whenever a tab is being created or closed, perform a diff algorithm\r\n      // on the active tabs list and create or delete the dummy tabs.\r\n      this.tabsList.pipe(\r\n        takeUntil(teardown$),\r\n        distinctUntilChanged((a, b) => {\r\n          const keysA = Object.keys(a);\r\n          const keysB = new Set(Object.keys(b));\r\n          return keysA.length === keysB.size && keysA.every(key => keysB.has(key));\r\n        }),\r\n      ).subscribe(targetState => {\r\n        const workingCopy = { ...targetState };\r\n        const tabs = new Set(Object.keys(workingCopy));\r\n        // currently opened tabs\r\n        const openedTabs = new Set(myStack.contentItems.map(ci => {\r\n          return (ci.config as any).componentState.originalId;\r\n        }));\r\n        for (const key of tabs) {\r\n          if (openedTabs.has(key)) {\r\n            // item is both currently opened in dummy and background, nothing to do\r\n            openedTabs.delete(key);\r\n          } else {\r\n            // item is not opened in dummy, create a component\r\n            myStack.addChild({\r\n              type: 'component',\r\n              componentName: 'gl-wrapper',\r\n              title: targetState[key].config.title,\r\n              reorderEnabled: false,\r\n              componentState: {\r\n                originalId: key,\r\n              },\r\n            } as any)\r\n          }\r\n        }\r\n        // The remaining tabs are opened in the dummy but not in the background, so close the dummy.\r\n        for (const tab of openedTabs) {\r\n          const tabObj = myStack.contentItems.find(j => (j.config as any).componentState.originalId === tab);\r\n          tabObj.remove();\r\n        }\r\n      });\r\n    };\r\n\r\n    this.goldenLayout.on('popIn', () => {\r\n      this.poppedIn = true;\r\n      this.openedComponents.forEach(c => {\r\n        if (implementsGlOnPopin(c)) {\r\n          c.glOnPopin();\r\n        }\r\n      });\r\n    });\r\n\r\n    // Overwrite the 'getComponent' method to dynamically resolve JS components.\r\n    // We need to do this, because the component map is not flexible enough for us since we can dynamically chainload plugins.\r\n    this.goldenLayout.getComponent = (type) => {\r\n      if (isDevMode()) {\r\n        console.log(`Resolving component ${type}`);\r\n      }\r\n      return this.buildConstructor(type);\r\n    };\r\n    this.goldenLayout.on('stackCreated', (stack) => {\r\n      const customHeaderElement = document.createElement('li');\r\n      customHeaderElement.classList.add('custom-header');\r\n      customHeaderElement.style.display = 'none';\r\n      const ctr = stack.header.controlsContainer[0] as HTMLUListElement;\r\n      let element: ComponentRef<any> = null;\r\n\r\n      ctr.prepend(customHeaderElement);\r\n\r\n      const disposeControl = () => {\r\n        customHeaderElement.style.display = 'none';\r\n        if (element) {\r\n          customHeaderElement.childNodes.forEach(e => customHeaderElement.removeChild(e));\r\n          element.destroy();\r\n          element = null;\r\n          stack.header._updateTabSizes();\r\n        }\r\n      };\r\n      const bootstrapComponent = (ct: Type<any>, tokens: StaticProvider[], injector: Injector) => {\r\n        if (element) {\r\n          disposeControl();\r\n        }\r\n        customHeaderElement.style.display = '';\r\n        const factory = this.componentFactoryResolver.resolveComponentFactory(ct);\r\n        const headerInjector = Injector.create(tokens, injector);\r\n        element = this.viewContainer.createComponent(factory, undefined, headerInjector);\r\n        customHeaderElement.prepend(element.location.nativeElement);\r\n        stack.header._updateTabSizes();\r\n      };\r\n\r\n      // Wait until the content item is loaded and done\r\n      stack.activeContentItem$.pipe(\r\n        switchMap((contentItem: GoldenLayout.ContentItem) => {\r\n          if (!contentItem || !contentItem.isComponent) {\r\n            return of(null);\r\n          }\r\n          return (contentItem as any).instance || of(null);\r\n        }), switchMap((cr: ComponentRef<any> | null) => {\r\n          if (!cr) {\r\n            return Promise.all([null, null, null]);\r\n          }\r\n          const inst = cr.instance.headerComponent;\r\n          const tokens = cr.instance.additionalTokens;\r\n          return Promise.all([\r\n            Promise.resolve(inst),\r\n            Promise.resolve(tokens),\r\n            Promise.resolve(cr)\r\n          ]);\r\n        })\r\n      ).subscribe(([header, tokens, componentRef]) => {\r\n        // This is the currently visible content item, after it's loaded.\r\n        // Therefore, we can check whether (and what) to render as header component here.\r\n        if (!header || !componentRef) {\r\n          disposeControl();\r\n        } else {\r\n          bootstrapComponent(\r\n            header,\r\n            tokens || [],\r\n            componentRef.injector\r\n          );\r\n        }\r\n      }, disposeControl, disposeControl);\r\n    });\r\n    // Initialize the layout.\r\n    this.goldenLayout.on('initialised', () => {\r\n      window.requestAnimationFrame(() => {\r\n        if (layout.maximisedItemId) {\r\n          const c = GetComponentFromLayoutManager(this.goldenLayout, layout.maximisedItemId);\r\n          if (c) {\r\n            (this.goldenLayout as any).generateAndMaximiseDummyStack(c.parent, layout.maximisedItemId);\r\n          }\r\n        }\r\n      });\r\n    });\r\n    this.goldenLayout.init();\r\n    this.goldenLayout.on('stateChanged', this.pushStateChange);\r\n    this.goldenLayout.on('itemDragged', this.pauseStateChange);\r\n    this.goldenLayout.on('itemDropped', this.resumeStateChange);\r\n    this.goldenLayout.on('tabActivated', this.pushTabActivated);\r\n    this.goldenLayout.on(lm.__lm.utils.EventEmitter.ALL_EVENT, this._eventEmitter.emit, this._eventEmitter);\r\n    this._eventEmitter.emit('initialised');\r\n  }\r\n\r\n  /**\r\n   * Build a 'virtual' constructor which is used to pass the components to goldenLayout\r\n   * @param componentType\r\n   */\r\n  private buildConstructor(componentName: string): ComponentInitCallback {\r\n    // Can't use an ES6 lambda here, since it is not a constructor\r\n    const self = this;\r\n    return function (container: GoldenLayout.Container, componentState: any) {\r\n      const glComponent = container.parent;\r\n      if (glComponent.config.id) {\r\n        glComponent.id = glComponent.config.id as string;\r\n      } else {\r\n        glComponent.id = uuid();\r\n        glComponent.config.id = glComponent.id;\r\n      }\r\n\r\n      const d = new Deferred<any>();\r\n      self.ngZone.run(() => {\r\n        // Wait until the component registry can provide a type for the component\r\n        // TBD: Maybe add a timeout here?\r\n        const componentPromise = self.componentRegistry.waitForComponent(componentName);\r\n        componentPromise.then((componentType) => {\r\n          // We got our component type\r\n          if (isDevMode()) {\r\n            console.log(`Component ${componentName} returned from componentRegistry`);\r\n          }\r\n          // Create an instance of the angular component.\r\n          const factory = self.componentFactoryResolver.resolveComponentFactory(componentType);\r\n          let failedComponent: string = null;\r\n          if (componentType === self.fallbackComponent) {\r\n            // Failed to find the component constructor **AND** we have a fallback component defined,\r\n            // so lookup the failed component's name and inject it into the fallback component.\r\n            failedComponent = (container as any)._config.componentName;\r\n          }\r\n          const injector = self._createComponentInjector(container, componentState, failedComponent);\r\n          const componentRef = self.viewContainer.createComponent(factory, undefined, injector);\r\n\r\n          // Bind the new component to container's client DOM element.\r\n          container.getElement().append($(componentRef.location.nativeElement));\r\n          self._bindEventHooks(container, componentRef.instance);\r\n          (container as any).__ngComponent = componentRef.instance;\r\n          self.openedComponents.push(componentRef.instance);\r\n          let destroyed = false;\r\n          const destroyFn = () => {\r\n            if (!destroyed) {\r\n              destroyed = true;\r\n              self.openedComponents = self.openedComponents.filter(i => i !== componentRef.instance);\r\n              $(componentRef.location.nativeElement).remove();\r\n              componentRef.destroy();\r\n            }\r\n          };\r\n\r\n          // Listen to containerDestroy and window beforeunload, preventing a double-destroy\r\n          container.on('destroy', destroyFn);\r\n          self.onUnloaded.promise.then(destroyFn);\r\n          d.resolve(componentRef);\r\n        });\r\n      });\r\n      return d.promise;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates an injector capable of injecting the GoldenLayout object,\r\n   * component container, and initial component state.\r\n   */\r\n  private _createComponentInjector(\r\n    container: GoldenLayout.Container,\r\n    componentState: any,\r\n    failed: string | null,\r\n  ): Injector {\r\n    const providers = [\r\n      {\r\n        provide: GoldenLayoutContainer,\r\n        useValue: container,\r\n      },\r\n      {\r\n        provide: GoldenLayoutComponentState,\r\n        useValue: componentState,\r\n      },\r\n      {\r\n        provide: GoldenLayoutEventHub,\r\n        useValue: this.goldenLayout.eventHub,\r\n      },\r\n      {\r\n        provide: GoldenLayoutComponentHost,\r\n        useValue: this,\r\n      }\r\n    ];\r\n    if (!!failed) {\r\n      providers.push({\r\n        provide: FailedComponent,\r\n        useValue: failed,\r\n      });\r\n    }\r\n    return Injector.create(providers, this.injector);\r\n  }\r\n\r\n  /**\r\n   * Registers an event handler for each implemented hook.\r\n   * @param container Golden Layout component container.\r\n   * @param component Angular component instance.\r\n   */\r\n  private _bindEventHooks(container: GoldenLayout.Container, component: any): void {\r\n    if (implementsGlOnResize(component)) {\r\n      container.on('resize', () => {\r\n        component.glOnResize();\r\n      });\r\n    }\r\n\r\n    if (implementsGlOnShow(component)) {\r\n      container.on('show', () => {\r\n        component.glOnShow();\r\n      });\r\n    }\r\n\r\n    if (implementsGlOnHide(component)) {\r\n      container.on('hide', () => {\r\n        component.glOnHide();\r\n      });\r\n    }\r\n\r\n    if (implementsGlOnTab(component)) {\r\n      container.on('tab', (tab) => {\r\n        component.glOnTab(tab);\r\n      });\r\n    }\r\n\r\n    if (implementsGlOnClose(component)) {\r\n      const containerClose = container.close.bind(container);\r\n      container.close = () => {\r\n        if (!(container as any)._config.isClosable) {\r\n          return false;\r\n        }\r\n        component.glOnClose().then(() => {\r\n          containerClose();\r\n        }, () => { /* Prevent close, don't care about rejections */ });\r\n      };\r\n    }\r\n  }\r\n}\r\n","import { NgModule, ModuleWithProviders, ANALYZE_FOR_ENTRY_COMPONENTS, Type, Provider } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { GoldenLayoutComponent } from './golden-layout.component';\r\nimport { RootWindowService } from './root-window.service';\r\nimport * as config from './config';\r\nimport { ComponentRegistryService } from './component-registry.service';\r\nimport { FallbackComponent } from './fallback';\r\nimport { PluginRegistryService, MockPluginRegistryService } from './plugin-registry.service';\r\nimport { WindowSynchronizerService, MockWindowSynchronizerService } from './window-sync.service';\r\nimport { PluginURLProvider } from './plugin-url.service';\r\nimport { WrapperComponent } from './wrapper.component';\r\n\r\n@NgModule({\r\n  declarations: [GoldenLayoutComponent, WrapperComponent],\r\n  exports: [GoldenLayoutComponent],\r\n  imports: [CommonModule]\r\n})\r\nexport class GoldenLayoutModule {\r\n  public static forRoot(types: config.ComponentType[], fallback?: Type<any>, pluginDeps?: config.PluginDependencyType[]): ModuleWithProviders<GoldenLayoutModule> {\r\n    return {\r\n      ngModule: GoldenLayoutModule,\r\n      providers: [\r\n        ComponentRegistryService,\r\n        RootWindowService,\r\n        PluginRegistryService,\r\n        PluginURLProvider,\r\n        WindowSynchronizerService,\r\n        { provide: config.GoldenLayoutComponents, useValue: types, },\r\n        { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: [types, fallback, WrapperComponent], multi: true },\r\n        { provide: config.GoldenLayoutPluginDependency, useValue: pluginDeps },\r\n        { provide: FallbackComponent, useValue: fallback },\r\n      ],\r\n    };\r\n  }\r\n\r\n  public static forChild(types: config.ComponentType[], fallback?: Type<any>): Provider[] {\r\n    return [\r\n      ComponentRegistryService,\r\n      { provide: PluginRegistryService, useClass: MockPluginRegistryService },\r\n      { provide: WindowSynchronizerService, useClass: MockWindowSynchronizerService },\r\n      { provide: PluginURLProvider, useValue: null },\r\n      { provide: config.GoldenLayoutComponents, useValue: types, },\r\n      { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: [types, fallback, WrapperComponent], multi: true },\r\n      { provide: FallbackComponent, useValue: fallback },\r\n    ];\r\n  }\r\n}\r\n\r\n"]}